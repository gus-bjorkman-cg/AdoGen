using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using AdoGen.Generator.Diagnostics;

namespace AdoGen.Generator.Emitters;

internal static class DtoMapperEmitter
{
    private const string AbstractionsLib = "AdoGen.Abstractions";
    private const string InterfaceSqlResult = $"{AbstractionsLib}.ISqlResult";

    public static void Emit(SourceProductionContext spc, (INamedTypeSymbol dto, bool _, bool missingInterface) data)
    {
        var (dto, _, missingInterface) = data;

        if (missingInterface)
        {
            spc.ReportDiagnostic(Diagnostic.Create(SqlDiagnostics.MissingSqlResultInterface, Location.None, InterfaceSqlResult));
            return;
        }

        var isPartial = dto.DeclaringSyntaxReferences
            .Select(r => r.GetSyntax())
            .OfType<TypeDeclarationSyntax>()
            .Any(t => t.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)));

        if (!isPartial) return;

        var props = dto.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public && !p.IsStatic)
            .ToArray();

        var setUsingConstructor = dto.Constructors.Any(x => x.Parameters.Length > 0);

        var ordinals = new StringBuilder();
        var init = new StringBuilder();
        var read = new StringBuilder();
        var sep = setUsingConstructor ? ":" : "=";
        var needsEnumCastHelper = false;

        if (setUsingConstructor) read.Append('(').AppendLine();
        else read.AppendLine("{");

        for (var i = 0; i < props.Length; i++)
        {
            var p = props[i];
            var ordinalField = $"{p.Name}Ordinal";
            var isLast = i == props.Length - 1;
            
            var getterExpr = EmitReaderGet(p, ordinalField, out bool usedFallback, out bool needsEnumCastForThis);

            if (usedFallback)
            {
                // Report analyzer diagnostic for the fallback path
                var loc = p.Locations.FirstOrDefault() ?? dto.Locations.FirstOrDefault() ?? Location.None;
                spc.ReportDiagnostic(Diagnostic.Create(
                    SqlDiagnostics.UsesFallbackGetFieldValue,
                    loc,
                    p.Name,
                    p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)));
            }

            if (needsEnumCastForThis) needsEnumCastHelper = true;
            
            ordinals.AppendLine($"    private static int {ordinalField};");
            init.AppendLine($"            {ordinalField} = reader.GetOrdinal(\"{p.Name}\");");
            read.AppendLine($"            {p.Name} {sep} {getterExpr}{(isLast ? "" : ",")}");
        }

        read.Append(setUsingConstructor ? "        )" : "        }");

        var dtoTypeName = dto.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var typeKeyword = dto.IsRecord ? "record" : "class";
        var ns = dto.ContainingNamespace.IsGlobalNamespace ? "GlobalNamespace" : dto.ContainingNamespace.ToDisplayString();
        var castHelper = needsEnumCastHelper ? EnumHelper : "";

        var src = $$"""
            // <auto-generated />
            using System.Runtime.CompilerServices;
            using Microsoft.Data.SqlClient;
            using AdoGen.Abstractions;

            namespace {{ns}};

            public sealed partial {{typeKeyword}} {{dto.Name}} : ISqlResult<{{dtoTypeName}}>
            {
                private static bool IsInitialized;
            {{ordinals}}
                public static {{dtoTypeName}} Map(SqlDataReader reader)
                {
                    if (!IsInitialized)
                    {
            {{init}}
                        IsInitialized = true;
                    }

                    return new {{dtoTypeName}}{{read}};
                }{{castHelper}}
            }
            """;

        spc.AddSource($"{dto.Name}Mapper.g.cs", src);
    }

    private const string EnumHelper =
        """
         
             private static TEnum EnumCast<TUnderlying, TEnum>(TUnderlying value)
                 where TUnderlying : unmanaged
                 where TEnum : unmanaged
                 => Unsafe.As<TUnderlying, TEnum>(ref value);
         """;
    
    private static string EmitReaderGet(
        IPropertySymbol p,
        string ordinalField,
        out bool usedFallback,
        out bool needsEnumCastHelper)
    {
        usedFallback = false;
        needsEnumCastHelper = false;

        var type = p.Type;
        var typeName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        // Nullable<T> handling
        if (type is INamedTypeSymbol nts &&
            nts.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T)
        {
            var inner = nts.TypeArguments[0];
            var innerName = inner.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            // Enum? special-case: read underlying & cast
            if (inner.TypeKind == TypeKind.Enum)
            {
                var (underlyingGetter, canUnsafeCast, fallback) = EmitEnumGet(inner, ordinalField);
                usedFallback = fallback;
                needsEnumCastHelper = true;
                // reader.IsDBNull ? null : EnumCast<underlying, Enum>(reader.GetUnderlying(...))
                var underlyingName = ((INamedTypeSymbol)inner).EnumUnderlyingType!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                return $"reader.IsDBNull({ordinalField}) ? (global::System.Nullable<{innerName}>)null : EnumCast<{underlyingName}, {innerName}>({underlyingGetter})";
            }

            // DateOnly? / TimeOnly?
            if (innerName == "global::System.DateOnly")
            {
                return $"reader.IsDBNull({ordinalField}) ? (global::System.DateOnly?)null : global::System.DateOnly.FromDateTime(reader.GetDateTime({ordinalField}))";
            }
            if (innerName == "global::System.TimeOnly")
            {
                return $"reader.IsDBNull({ordinalField}) ? (global::System.TimeOnly?)null : global::System.TimeOnly.FromTimeSpan(reader.GetTimeSpan({ordinalField}))";
            }

            // CLR fast-path (nullable)
            if (ClrGetters.TryGetValue(innerName, out var clrGetterName))
            {
                return $"reader.IsDBNull({ordinalField}) ? (global::System.Nullable<{innerName}>)null : reader.Get{clrGetterName}({ordinalField})";
            }
            
            // string?
            if (innerName == "global::System.String")
                return $"reader.IsDBNull({ordinalField}) ? null : reader.GetString({ordinalField})";

            // Fallback for unknown nullable types
            usedFallback = true;
            return $"reader.IsDBNull({ordinalField}) ? (global::System.Nullable<{innerName}>)null : reader.GetFieldValue<{innerName}>({ordinalField})";
        }

        // Non-nullable enum
        if (type.TypeKind == TypeKind.Enum)
        {
            var (underlyingGetter, canUnsafeCast, fallback) = EmitEnumGet(type, ordinalField);
            usedFallback = fallback;
            needsEnumCastHelper = true;
            var underlyingName = ((INamedTypeSymbol)type).EnumUnderlyingType!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var enumName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            return $"EnumCast<{underlyingName}, {enumName}>({underlyingGetter})";
        }

        // string?
        if (typeName == "string")
            return $"reader.IsDBNull({ordinalField}) ? null : reader.GetString({ordinalField})";
        if (typeName == "string?")
            return $"reader.IsDBNull({ordinalField}) ? null : reader.GetString({ordinalField})";
        
        // DateOnly / TimeOnly (non-nullable)
        if (typeName == "global::System.DateOnly")
            return $"global::System.DateOnly.FromDateTime(reader.GetDateTime({ordinalField}))";
        if (typeName == "global::System.TimeOnly")
            return $"global::System.TimeOnly.FromTimeSpan(reader.GetTimeSpan({ordinalField}))";

        // CLR fast-path
        if (ClrGetters.TryGetValue(typeName, out var clrGetter))
            return $"reader.Get{clrGetter}({ordinalField})";

        // Fallback (rare)
        usedFallback = true;
        return $"reader.GetFieldValue<{typeName}>({ordinalField})";
    }

    /// <summary>
    /// Emits the getter expression for an enum type by reading its underlying storage.
    /// Returns (getterExpression, canUnsafeCast, usedFallback).
    /// </summary>
    private static (string expr, bool canUnsafeCast, bool usedFallback) EmitEnumGet(
        ITypeSymbol enumType,
        string ordinalField)
    {
        var underlying = ((INamedTypeSymbol)enumType).EnumUnderlyingType!;
        switch (underlying.SpecialType)
        {
            case SpecialType.System_Byte:
                return ($"reader.GetByte({ordinalField})", true, false);
            case SpecialType.System_Int16:
                return ($"reader.GetInt16({ordinalField})", true, false);
            case SpecialType.System_Int32:
                return ($"reader.GetInt32({ordinalField})", true, false);
            case SpecialType.System_Int64:
                return ($"reader.GetInt64({ordinalField})", true, false);

            // Unsigned / sbyte: no direct SqlDataReader getters that are robust across SQL types
            // We fall back to GetFieldValue<TUnderlying> to avoid accidental value corruption.
            case SpecialType.System_SByte:
            case SpecialType.System_UInt16:
            case SpecialType.System_UInt32:
            case SpecialType.System_UInt64:
            default:
                var underlyingName = underlying.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                return ($"reader.GetFieldValue<{underlyingName}>({ordinalField})", true, true);
        }
    }
    
    private static readonly Dictionary<string, string> ClrGetters = new()
    {
        ["global::System.Boolean"] = "Boolean",
        ["global::System.Byte"] = "Byte",
        ["global::System.Int16"] = "Int16",
        ["global::System.Int32"] = "Int32",
        ["global::System.Int64"] = "Int64",
        ["global::System.Single"] = "Float",
        ["global::System.Double"] = "Double",
        ["global::System.Decimal"] = "Decimal",
        ["global::System.String"] = "String",
        ["global::System.DateTime"] = "DateTime",
        ["global::System.Guid"] = "Guid"
        // DateOnly / TimeOnly are special-cased (not direct Get* methods)
    };
}
