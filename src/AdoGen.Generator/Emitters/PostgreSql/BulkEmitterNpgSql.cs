using System;
using System.Linq;
using System.Text;
using AdoGen.Generator.Diagnostics;
using AdoGen.Generator.Extensions;
using AdoGen.Generator.Models;
using AdoGen.Generator.Pipelines;
using Microsoft.CodeAnalysis;

namespace AdoGen.Generator.Emitters.PostgreSql;

internal sealed class BulkEmitterNpgSql : IEmitter
{
    private BulkEmitterNpgSql() { }
    public static BulkEmitterNpgSql Instance { get; } = new();
    
    public bool IsMatch(SqlModelKind kind, SqlProviderKind provider)
        => provider is SqlProviderKind.PostgreSql && kind >= SqlModelKind.Bulk;

    public void Handle(SourceProductionContext spc, ValidatedDiscoveryDto validatedDto)
    {
        var (discoveryDto, profileInfo, _) = validatedDto;
        var dto = discoveryDto.Dto;
        
        var dtoProps = dto.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public && !p.IsStatic)
            .OrderBy(x =>
            {
                var loc = x.Locations.FirstOrDefault(l => l.IsInSource);
                return loc is null ? int.MaxValue : loc.SourceSpan.Start;
            })
            .ThenBy(x => x.Name, StringComparer.Ordinal)
            .ToArray();

        var ns = dto.ContainingNamespace.IsGlobalNamespace
            ? "GlobalNamespace"
            : dto.ContainingNamespace.ToDisplayString();
        var dtoTypeName = dto.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        var tempTableName = $"adoGen_{dto.Name.ToLowerInvariant()}_tmp";
        var bulkTypeName = dto.Name + "NpgsqlBulk";

        var keys = profileInfo.Keys.ToArray();
        if (keys.Length == 0)
        {
            spc.ReportDiagnostic(Diagnostic.Create(SqlDiagnostics.MissingKey,
                dto.Locations.FirstOrDefault() ?? Location.None, dto.Name));
            return;
        }

        // Build join condition using quoted identifiers
        var joinOn = string.Join(" AND ", keys.Select(k =>
        {
            var col = profileInfo.ParamsByProperty[k].ParameterName;
            return $"S.\"{col}\" = T.\"{col}\"";
        }));

        var insertCols = dtoProps
            .Where(p => !profileInfo.IdentityKeys.Contains(p.Name))
            .Select(p => profileInfo.ParamsByProperty[p.Name].ParameterName)
            .ToArray();

        var insertSelect = insertCols.Select(c => $"S.\"{c}\"").ToArray();

        var nonKeyNonIdentity = dtoProps
            .Where(p => !profileInfo.Keys.Contains(p.Name) && !profileInfo.IdentityKeys.Contains(p.Name))
            .ToArray();

        var updateSet = string.Join(",\n        ", nonKeyNonIdentity
            .Select(p => profileInfo.ParamsByProperty[p.Name].ParameterName)
            .Select(c => $"    \"{c}\" = S.\"{c}\""));

        // CREATE TEMP TABLE
        var sbColDefs = new StringBuilder();
        for (var i = 0; i < dtoProps.Length; i++)
        {
            var p = dtoProps[i];
            var cfg = profileInfo.ParamsByProperty[p.Name];
            var sqlType = SqlTypeLiterals.ToSqlTypeLiteral(cfg);
            var isNullable = p.IsNullableProperty(cfg);
            var nullability = isNullable ? "NULL" : "NOT NULL";
            sbColDefs.AppendLine($"    \"{cfg.ParameterName}\" {sqlType} {nullability},");
        }

        sbColDefs.Append("    \"operation\" CHAR(1) NOT NULL");

        var tempTableSqlRaw = $"CREATE TEMP TABLE IF NOT EXISTS \"{tempTableName}\"(\n{sbColDefs});";
        // Escape for verbatim string: double all quotes
        var tempTableSqlEscaped = tempTableSqlRaw.Replace("\"", "\"\"");

        var schemaTable = $"\"{profileInfo.Schema}\".\"{profileInfo.Table}\"";
        var tempTableRef = $"\"{tempTableName}\"";

        var applySql = BuildApplySql();
        var applySqlEscaped = applySql.Replace("\"", "\"\"");
        var typeKeyword = dto.IsRecord ? "record" : "class";

        var copyColumnsEscaped = dtoProps.Select(p => $"\\\"" + profileInfo.ParamsByProperty[p.Name].ParameterName + "\\\"")
            .Concat(["\\\"operation\\\""]).ToArray();
        var copyCommand = $"COPY \\\"{tempTableName}\\\" ({string.Join(", ", copyColumnsEscaped)}) FROM STDIN (FORMAT BINARY)";

        var src = $$$""""
                     // <auto-generated />
                     #nullable enable
                     using System;
                     using System.Data;
                     using System.Collections.Generic;
                     using System.Threading;
                     using System.Threading.Tasks;
                     using Npgsql;
                     using AdoGen.PostgreSql;

                     namespace {{{ns}}};

                     public sealed partial {{{typeKeyword}}} {{{dto.Name}}} : INpgsqlBulkModel<{{{dtoTypeName}}}>;

                     public sealed class {{{bulkTypeName}}} : BulkBatchNpg<{{{dtoTypeName}}}>
                     {
                         private const string _tempTableName = "{{{tempTableName}}}";

                         private const string _sqlCreateTempTable = @"{{{tempTableSqlEscaped}}}";

                         private const string _sqlApply = @"{{{applySqlEscaped}}}";

                         private const string _copyCommand = "{{{copyCommand}}}";

                         protected override string SqlCreateTempTable => _sqlCreateTempTable;
                         protected override string TempTableName => _tempTableName;
                         protected override string SqlApplyWithIndex => _sqlApply;
                         protected override string SqlApplyNoIndex => _sqlApply;
                         protected override int FieldCount => {{{dtoProps.Length + 1}}};

                         public {{{bulkTypeName}}}(int capacity = 0) : base(capacity) { }

                         protected override async ValueTask WriteItemsToServerAsync(NpgsqlConnection connection, NpgsqlTransaction transaction, CancellationToken ct)
                         {
                             // COPY BINARY is the fast path in PostgreSQL.
                             // Note: BeginBinaryImport is sync in Npgsql; we still honor CancellationToken during row loop via Write...Async.
                             await using var importer = connection.BeginBinaryImport(_copyCommand);

                             for (var i = 0; i < Items.Count; i++)
                             {
                                 ct.ThrowIfCancellationRequested();

                                 var item = Items[i];
                                 var op = Operations[i].Value;

                                 await importer.StartRowAsync(ct).ConfigureAwait(false);
                     {{{EmitImporterWrites(dtoProps)}}}
                                 importer.Write(op);
                             }

                             await importer.CompleteAsync(ct).ConfigureAwait(false);
                         }
                     }
                     """";

        spc.AddSource($"{dto.Name}Bulk.Npgsql.g.cs", src);
        return;

        string BuildApplySql()
        {
            var sb = new StringBuilder();

            // we keep it simple/explicit (no TRY/CATCH). Temp tables are scoped to session.
            sb.AppendLine("WITH updated AS (");
            if (nonKeyNonIdentity.Length > 0)
            {
                sb.AppendLine($"    UPDATE {schemaTable} AS T");
                sb.AppendLine("    SET");
                sb.AppendLine("        " + updateSet);
                sb.AppendLine($"    FROM {tempTableRef} AS S");
                sb.AppendLine($"    WHERE S.\"operation\" = 'U' AND {joinOn}");
                sb.AppendLine("    RETURNING 1");
            }
            else
            {
                sb.AppendLine("    SELECT 1 WHERE false");
            }

            sb.AppendLine(")");

            // INSERT
            sb.AppendLine(", inserted AS (");
            if (insertCols.Length > 0)
            {
                sb.AppendLine(
                    $"    INSERT INTO {schemaTable} ({string.Join(", ", insertCols.Select(c => $"\"{c}\""))})");
                sb.AppendLine($"    SELECT {string.Join(", ", insertSelect)}");
                sb.AppendLine($"    FROM {tempTableRef} AS S");
                sb.AppendLine("    WHERE S.\"operation\" = 'I'");
                sb.AppendLine("    RETURNING 1");
            }
            else
            {
                sb.AppendLine("    SELECT 1 WHERE false");
            }

            sb.AppendLine(")");

            // DELETE
            sb.AppendLine(", deleted AS (");
            sb.AppendLine($"    DELETE FROM {schemaTable} AS T");
            sb.AppendLine($"    USING {tempTableRef} AS S");
            sb.AppendLine($"    WHERE S.\"operation\" = 'D' AND {joinOn}");
            sb.AppendLine("    RETURNING 1");
            sb.AppendLine(")");

            sb.AppendLine("SELECT");
            sb.AppendLine("    (SELECT COUNT(*) FROM inserted) AS Inserted,");
            sb.AppendLine("    (SELECT COUNT(*) FROM updated) AS Updated,");
            sb.AppendLine("    (SELECT COUNT(*) FROM deleted) AS Deleted;");

            return sb.ToString().TrimEnd();
        }
    }

    private static string EmitImporterWrites(IPropertySymbol[] dtoProps)
    {
        var sb = new StringBuilder();
        for (var i = 0; i < dtoProps.Length; i++)
        {
            var p = dtoProps[i];
            var accessor = ResolveNpgsqlBulkWriteAccessor(p);
            sb.AppendLine(
                $"            importer.Write({accessor});");
        }

        return sb.ToString().TrimEnd();
    }

    /// <summary>
    /// Returns the accessor expression for a property in a COPY BINARY write.
    /// Enum values must be cast to their underlying type because Npgsql COPY BINARY
    /// does not support writing .NET enum types directly.
    /// </summary>
    private static string ResolveNpgsqlBulkWriteAccessor(IPropertySymbol p)
    {
        var (underlying, isNullable) = p.Type.UnwrapNullable();
        if (underlying.TypeKind != TypeKind.Enum || underlying is not INamedTypeSymbol enumType)
            return $"item.{p.Name}";

        var castType = enumType.EnumUnderlyingType?.SpecialType switch
        {
            SpecialType.System_Byte => "byte",
            SpecialType.System_SByte => "sbyte",
            SpecialType.System_Int16 => "short",
            SpecialType.System_UInt16 => "ushort",
            SpecialType.System_Int32 => "int",
            SpecialType.System_UInt32 => "uint",
            SpecialType.System_Int64 => "long",
            SpecialType.System_UInt64 => "ulong",
            _ => "int"
        };

        return isNullable
            ? $"item.{p.Name}.HasValue ? ({castType})item.{p.Name}.Value : DBNull.Value"
            : $"({castType})item.{p.Name}";
    }
}