using System.Linq;
using System.Text;
using AdoGen.Generator.Diagnostics;
using AdoGen.Generator.Extensions;
using AdoGen.Generator.Models;
using AdoGen.Generator.Pipelines;
using Microsoft.CodeAnalysis;

namespace AdoGen.Generator.Emitters.PostgreSql;

internal sealed class DomainOpsEmitterNpgSql : IEmitter
{
    private DomainOpsEmitterNpgSql() { }
    public static DomainOpsEmitterNpgSql Instance { get; } = new();
    
    public bool IsMatch(SqlModelKind kind, SqlProviderKind provider) =>
        provider is SqlProviderKind.PostgreSql && kind >= SqlModelKind.Domain;

    public void Handle(SourceProductionContext spc, ValidatedDiscoveryDto validatedDto)
    {
        var (discoveryDto, profileInfo, _) = validatedDto;
        var dto = discoveryDto.Dto;
        var dtoProps = profileInfo.DtoProperties;

        var ns = profileInfo.Namespace;
        var dtoTypeName = dto.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var typeKeyword = dto.IsRecord ? "record" : "class";

        // CREATE TABLE
        var sbColDefs = new StringBuilder();
        for (var i = 0; i < dtoProps.Length; i++)
        {
            var p = dtoProps[i];
            var cfg = profileInfo.ParamsByProperty[p.Name];
            var sqlType = cfg.SqlTypeLiteral;
            var isNullable = p.IsNullableProperty(cfg);
            var nullability = isNullable ? "NULL" : "NOT NULL";
            var identity = profileInfo.IdentityKeys.Contains(p.Name) ? " GENERATED BY DEFAULT AS IDENTITY" : "";
            var defaultSql = p.ResolveDefaultSql(cfg, SqlProviderKind.PostgreSql);
            var defaultClause = defaultSql is not null ? $" {defaultSql}" : "";

            var comma = i == dtoProps.Length - 1 ? "" : ",";
            sbColDefs.AppendLine($"            \"{cfg.ParameterName}\" {sqlType}{identity}{defaultClause} {nullability}{comma}");
        }

        if (profileInfo.Keys.Length > 0)
            sbColDefs.AppendLine($"        ,CONSTRAINT \"PK_{profileInfo.Table}\" PRIMARY KEY ({string.Join(", ", profileInfo.Keys.Select(k => $"\"{k}\""))})");

        var colDefs = sbColDefs.ToString().TrimEnd();
        var createTableSql =
            $"CREATE TABLE IF NOT EXISTS \"{profileInfo.Schema}\".\"{profileInfo.Table}\"(\n{colDefs});\n";

        // INSERT (skip identity)
        var nonIdentityProp = dtoProps.Where(p => !profileInfo.IdentityKeys.Contains(p.Name)).ToArray();
        var nonIdentityPropCount = nonIdentityProp.Length;

        var insertCols = nonIdentityProp
            .Select(p => $"\"{profileInfo.ParamsByProperty[p.Name].ParameterName}\"")
            .ToArray();

        var insertParams = nonIdentityProp
            .Select(p => "@" + profileInfo.ParamsByProperty[p.Name].ParameterName)
            .ToArray();

        var insertSql =
            $"INSERT INTO \"{profileInfo.Schema}\".\"{profileInfo.Table}\" ({string.Join(", ", insertCols)}) VALUES ({string.Join(", ", insertParams)});";

        var insertBatchSql = $"INSERT INTO \"{profileInfo.Schema}\".\"{profileInfo.Table}\" ({string.Join(", ", insertCols)}) VALUES";

        // UPDATE/DELETE
        var nonKeyNonIdentity = dtoProps
            .Where(p => !profileInfo.Keys.Contains(p.Name) && !profileInfo.IdentityKeys.Contains(p.Name))
            .ToArray();

        var updateSet = string.Join(", ", nonKeyNonIdentity.Select(p =>
        {
            var col = profileInfo.ParamsByProperty[p.Name].ParameterName;
            return $"\"{col}\" = @{col}";
        }));

        var whereClause = string.Join(" AND ", profileInfo.Keys.Select(k =>
        {
            var col = profileInfo.ParamsByProperty[k].ParameterName;
            return $"\"{col}\" = @{col}";
        }));

        var updateSql = $"UPDATE \"{profileInfo.Schema}\".\"{profileInfo.Table}\" SET {updateSet} WHERE {whereClause};";
        var deleteSql = $"DELETE FROM \"{profileInfo.Schema}\".\"{profileInfo.Table}\" WHERE {whereClause};";

        // UPSERT via ON CONFLICT
        var conflictKeys = profileInfo.Keys.Where(k => !profileInfo.IdentityKeys.Contains(k)).ToArray();
        string? upsertSql = null;
        if (conflictKeys.Length == 0)
        {
            spc.ReportDiagnostic(Diagnostic.Create(SqlDiagnostics.NoUpsertMatchKeys, dto.Locations.FirstOrDefault() ?? Location.None, dto.Name));
        }
        else
        {
            var updateSetOnConflict = string.Join(", ", dtoProps
                .Where(p => !profileInfo.Keys.Contains(p.Name) && !profileInfo.IdentityKeys.Contains(p.Name))
                .Select(p =>
                {
                    var col = profileInfo.ParamsByProperty[p.Name].ParameterName;
                    return $"\"{col}\" = EXCLUDED.\"{col}\"";
                }));

            upsertSql =
                $"{insertSql.TrimEnd(';')} ON CONFLICT ({string.Join(", ", conflictKeys.Select(k => $"\"{k}\""))}) DO UPDATE SET {updateSetOnConflict};";
        }

        var truncateSql = $"TRUNCATE TABLE \"{profileInfo.Schema}\".\"{profileInfo.Table}\";";

        var deleteBatchSrc = "";
        if (profileInfo.Keys.Length == 1)
        {
            var keyName = profileInfo.Keys[0];
            var keyType = profileInfo.ParamsByProperty[keyName].PropertyType
                .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var deleteBatchSql = $"DELETE FROM \\\"{profileInfo.Schema}\".\\\"{profileInfo.Table}\\\" WHERE \\\"{keyName}\\\" IN (";

            deleteBatchSrc =
                $@"
public sealed partial {typeKeyword} {dto.Name} : INpgsqlSingleIdModel<{dtoTypeName}, {keyType}>
{{
    private const string Pg_SqlDeleteBatchTemplate = ""{EscapeStringLiteral($@"DELETE FROM ""{profileInfo.Schema}"".""{profileInfo.Table}"" WHERE ""{keyName}"" IN (")}"";

    public static async ValueTask<int> DeleteAsync(NpgsqlConnection connection, List<{keyType}> ids, CancellationToken ct, NpgsqlTransaction? transaction = null, int? commandTimeout = null)
    {{
        if (ids is null || ids.Count == 0) return 0;
        if (connection.State != ConnectionState.Open) await connection.OpenAsync(ct).ConfigureAwait(false);

        var sb = new StringBuilder(Pg_SqlDeleteBatchTemplate);
        for (var i = 0; i < ids.Count; i++)
        {{
            if (i > 0) sb.Append(',');
            sb.Append($""@p{{i}}"");
        }}
        sb.Append(')');

        await using var cmd = connection.CreateCommand(sb.ToString(), CommandType.Text, transaction, commandTimeout);

        for (var i = 0; i < ids.Count; i++)
        {{
            cmd.Parameters.Add({dto.Name}Npgsql.CreateParameter{keyName}(ids[i], $""@p{{i}}""));
        }}

        return await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }}
}}
";
        }

        var src =
            $@"// <auto-generated />
#nullable enable
using System;
using System.Data;
using System.Text;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Npgsql;
using AdoGen.PostgreSql;

namespace {ns};
{deleteBatchSrc}
public sealed partial {typeKeyword} {dto.Name} : INpgsqlDomainModel<{dtoTypeName}>
{{
    private const string Pg_SqlCreateTable = @""{EscapeVerbatim(createTableSql)}"";
    private const string Pg_SqlInsert = ""{EscapeStringLiteral(insertSql)}"";
    private const string Pg_SqlInsertBatchTemplate = ""{EscapeStringLiteral(insertBatchSql)}"";
    private const string Pg_SqlUpdate = ""{EscapeStringLiteral(updateSql)}"";
    private const string Pg_SqlDelete = ""{EscapeStringLiteral(deleteSql)}"";
    private const string Pg_SqlTruncate = ""{EscapeStringLiteral(truncateSql)}"";
{(upsertSql is not null ? $"    private const string Pg_SqlUpsert = \"{EscapeStringLiteral(upsertSql)}\";" : "")}

    private const int Pg_NonIdentityPropertyCount = {nonIdentityPropCount};

    public static async ValueTask CreateTableAsync(NpgsqlConnection connection, CancellationToken ct, NpgsqlTransaction? transaction = null, int? commandTimeout = null)
    {{
        if (connection.State != ConnectionState.Open) await connection.OpenAsync(ct).ConfigureAwait(false);
        await using var cmd = connection.CreateCommand(Pg_SqlCreateTable, CommandType.Text, transaction, commandTimeout);
        await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }}

    public static async ValueTask<int> InsertAsync({dtoTypeName} model, NpgsqlConnection connection, CancellationToken ct, NpgsqlTransaction? transaction = null, int? commandTimeout = null)
    {{
        if (connection.State != ConnectionState.Open) await connection.OpenAsync(ct).ConfigureAwait(false);
        await using var cmd = connection.CreateCommand(Pg_SqlInsert, CommandType.Text, transaction, commandTimeout);
{ParamAdd("model")}        return await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }}

    public static async ValueTask<int> InsertAsync(List<{dtoTypeName}> models, NpgsqlConnection connection, CancellationToken ct, NpgsqlTransaction? transaction = null, int? commandTimeout = null)
    {{
        if (models is null || models.Count == 0) return 0;
        if (connection.State != ConnectionState.Open) await connection.OpenAsync(ct).ConfigureAwait(false);

        var sb = new StringBuilder(Pg_SqlInsertBatchTemplate);
        var paramIndex = 0;

        for (var modelIndex = 0; modelIndex < models.Count; modelIndex++)
        {{
            if (modelIndex > 0) sb.Append(',');
            sb.Append('(');
            for (var columnIndex = 0; columnIndex < Pg_NonIdentityPropertyCount; columnIndex++)
            {{
                if (columnIndex > 0) sb.Append(',');
                sb.Append($""@p{{paramIndex + columnIndex}}"");
            }}
            sb.Append(')');
            paramIndex += Pg_NonIdentityPropertyCount;
        }}

        await using var cmd = connection.CreateCommand(sb.ToString(), CommandType.Text, transaction, commandTimeout);
        paramIndex = 0;

        foreach (var model in models)
        {{
{ParamAddBatchFlat("model", "paramIndex")}        }}

        return await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }}

    public static async ValueTask<int> UpdateAsync({dtoTypeName} model, NpgsqlConnection connection, CancellationToken ct, NpgsqlTransaction? transaction = null, int? commandTimeout = null)
    {{
        if (connection.State != ConnectionState.Open) await connection.OpenAsync(ct).ConfigureAwait(false);
        await using var cmd = connection.CreateCommand(Pg_SqlUpdate, CommandType.Text, transaction, commandTimeout);
{ParamAddForUpdate("model")}        return await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }}

    public static async ValueTask<int> DeleteAsync({dtoTypeName} model, NpgsqlConnection connection, CancellationToken ct, NpgsqlTransaction? transaction = null, int? commandTimeout = null)
    {{
        if (connection.State != ConnectionState.Open) await connection.OpenAsync(ct).ConfigureAwait(false);
        await using var cmd = connection.CreateCommand(Pg_SqlDelete, CommandType.Text, transaction, commandTimeout);
{ParamAddForDelete("model")}        return await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }}

{(upsertSql is not null ? $@"    public static async ValueTask<int> UpsertAsync({dtoTypeName} model, NpgsqlConnection connection, CancellationToken ct, NpgsqlTransaction? transaction = null, int? commandTimeout = null)
    {{
        if (connection.State != ConnectionState.Open) await connection.OpenAsync(ct).ConfigureAwait(false);
        await using var cmd = connection.CreateCommand(Pg_SqlUpsert, CommandType.Text, transaction, commandTimeout);
{ParamAdd("model")}        return await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }}" : $@"    public static ValueTask<int> UpsertAsync({dtoTypeName} model, NpgsqlConnection connection, CancellationToken ct, NpgsqlTransaction? transaction = null, int? commandTimeout = null)
        => throw new System.NotSupportedException(""Upsert is not supported for {dto.Name} because all keys are identity columns."");")}

    public static async ValueTask<int> TruncateAsync(NpgsqlConnection connection, CancellationToken ct, NpgsqlTransaction? transaction = null, int? commandTimeout = null)
    {{
        if (connection.State != ConnectionState.Open) await connection.OpenAsync(ct).ConfigureAwait(false);
        await using var cmd = connection.CreateCommand(Pg_SqlTruncate, CommandType.Text, transaction, commandTimeout);
        return await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }}
}}
";

        spc.AddSource($"{dto.Name}DomainOps.Npgsql.g.cs", src);
        return;

        static string EscapeStringLiteral(string value) => value.Replace("\\", "\\\\").Replace("\"", "\\\"");
        static string EscapeVerbatim(string value) => value.Replace("\"", "\"\"");

        string ParamAdd(string modelName)
        {
            var sb = new StringBuilder();
            foreach (var p in dtoProps)
                sb.AppendLine($"        cmd.Parameters.Add({dto.Name}Npgsql.CreateParameter{p.Name}({modelName}.{p.Name}));");
            return sb.ToString();
        }

        string ParamAddForUpdate(string modelName)
        {
            var sb = new StringBuilder();
            foreach (var p in nonKeyNonIdentity)
                sb.AppendLine($"        cmd.Parameters.Add({dto.Name}Npgsql.CreateParameter{p.Name}({modelName}.{p.Name}));");
            foreach (var k in profileInfo.Keys)
                sb.AppendLine($"        cmd.Parameters.Add({dto.Name}Npgsql.CreateParameter{k}({modelName}.{k}));");
            return sb.ToString();
        }

        string ParamAddForDelete(string modelName)
        {
            var sb = new StringBuilder();
            foreach (var k in profileInfo.Keys)
                sb.AppendLine($"        cmd.Parameters.Add({dto.Name}Npgsql.CreateParameter{k}({modelName}.{k}));");
            return sb.ToString();
        }

        string ParamAddBatchFlat(string modelName, string indexName)
        {
            var sb = new StringBuilder();
            foreach (var p in nonIdentityProp)
            {
                sb.AppendLine($"            cmd.Parameters.Add({dto.Name}Npgsql.CreateParameter{p.Name}({modelName}.{p.Name}, $\"@p{{{indexName}}}\"));");
                sb.AppendLine($"            {indexName}++; ");
            }
            return sb.ToString();
        }
    }
}