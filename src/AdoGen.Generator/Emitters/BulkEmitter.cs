using System;
using AdoGen.Generator.Diagnostics;
using Microsoft.CodeAnalysis;
using System.Linq;
using System.Text;
using AdoGen.Generator.Extensions;
using AdoGen.Generator.Models;
using AdoGen.Generator.Pipelines;

namespace AdoGen.Generator.Emitters;

public static class BulkEmitter
{
    internal static void Emit(SourceProductionContext spc, DiscoveryDto discoveryDto, ProfileInfo info)
    {
        var (dto, kind, _, _) = discoveryDto;
        
        if (kind < SqlModelKind.Bulk) return;

        EmitWithInfo(spc, dto, info);
    }

    private static void EmitWithInfo(SourceProductionContext spc, INamedTypeSymbol dto, ProfileInfo info)
    {
        var dtoProps = dto.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public && !p.IsStatic)
            .OrderBy(x =>
            {
                var loc = x.Locations.FirstOrDefault(l => l.IsInSource);
                return loc is null ? int.MaxValue : loc.SourceSpan.Start;
            })
            .ThenBy(x => x.Name, StringComparer.Ordinal)
            .ToArray();

        var ns = dto.ContainingNamespace.IsGlobalNamespace ? "GlobalNamespace" : dto.ContainingNamespace.ToDisplayString();
        var dtoTypeName = dto.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        // --- Bulk metadata ---
        // Temp table name is stable per DTO type
        var tempTableName = $"#AdoGen_{dto.Name}";
        var bulkTypeName = dto.Name + "Bulk";

        // Keys / join predicate
        var keys = info.Keys.ToArray();
        if (keys.Length == 0)
        {
            spc.ReportDiagnostic(Diagnostic.Create(SqlDiagnostics.MissingKey, dto.Locations.FirstOrDefault() ?? Location.None, dto.Name));
            return;
        }

        var joinOn = string.Join(" AND ", keys.Select(k => $"S.[{k}] = T.[{k}]"));
        var idxCols = string.Join(", ", keys.Select(k => $"[{k}]"));
        var idxClause = $"        CREATE INDEX [IX_AdoGen_{info.Table}_Op_Key] ON {tempTableName} ([Operation], {idxCols});";

        // INSERT columns: skip identity keys (same rule as DomainOpsEmitter)
        var insertCols = dtoProps
            .Where(p => !info.IdentityKeys.Contains(p.Name))
            .Select(p => $"[{info.ParamsByProperty[p.Name].ParameterName}]")
            .ToArray();
        
        var insertSelect = dtoProps
            .Where(p => !info.IdentityKeys.Contains(p.Name))
            .Select(p => $"S.[{info.ParamsByProperty[p.Name].ParameterName}]")
            .ToArray();

        // UPDATE SET: non-key, non-identity (same as DomainOpsEmitter)
        var nonKeyNonIdentity = dtoProps
            .Where(p => !info.Keys.Contains(p.Name) && !info.IdentityKeys.Contains(p.Name))
            .ToArray();
        
        var updateSet = string.Join(",\n        ", nonKeyNonIdentity
            .Select(x => info.ParamsByProperty[x.Name].ParameterName)
            .Select(x => $"    T.[{x}] = S.[{x}]"));

        // CREATE TEMP TABLE (no identity clause here; it's just staging)
        var sbColDefs = new StringBuilder();
        for (var i = 0; i < dtoProps.Length; i++)
        {
            var p = dtoProps[i];
            var cfg = info.ParamsByProperty[p.Name];
            var sqlType = SqlTypeLiterals.ToSqlTypeLiteral(cfg);
            var isNullable = p.IsNullableProperty(cfg);
            var nullability = isNullable ? "NULL" : "NOT NULL";

            const string spaces = "            ";
            sbColDefs.AppendLine($"{spaces}[{cfg.ParameterName}] {sqlType} {nullability},");
        }
        sbColDefs.AppendLine("            [Operation] CHAR(1) NOT NULL");

        var tempTableSql =
            $"""
            CREATE TABLE {tempTableName}(
            {sbColDefs.ToString().TrimEnd()});
            """;

        // APPLY SQL variants
        var schemaTable = $"[{info.Schema}].[{info.Table}]";

        var applyNoIndex = BuildApplySql(withIndex: false);
        var applyWithIndex = BuildApplySql(withIndex: true);
        var typeKeyword = dto.IsRecord ? "record" : "class";

        // Generated file
        var src = $$$""""
            // <auto-generated />
            #nullable enable
            using System;
            using System.Data;
            using System.Collections.Generic;
            using System.Threading;
            using System.Threading.Tasks;
            using Microsoft.Data.SqlClient;
            using AdoGen.Abstractions;

            namespace {{{ns}}};

            public sealed partial {{{typeKeyword}}} {{{dto.Name}}} : ISqlBulkModel<{{{dtoTypeName}}}>;
            
            public sealed class {{{bulkTypeName}}} : BulkBatch<{{{dtoTypeName}}}>
            {
                private const string _tempTableName = "{{{tempTableName}}}";

                private const string _sqlCreateTempTable =
                    """
                    {{{tempTableSql}}}
                    """;

                private const string _sqlApply_NoIndex =
                    """
                    {{{applyNoIndex}}}
                    """;

                private const string _sqlApply_WithIndex =
                    """
                    {{{applyWithIndex}}}
                    """;

                protected override string SqlCreateTempTable => _sqlCreateTempTable;
                protected override string TempTableName => _tempTableName;
                protected override string SqlApplyWithIndex => _sqlApply_WithIndex;
                protected override string SqlApplyNoIndex => _sqlApply_NoIndex;
                protected override int FieldCount => {{{dtoProps.Length + 1}}};
            
                /// <summary>
                /// Initializes a new instance of the BulkBatch class with an optional initial capacity for
                /// the items and operations lists.
                /// </summary>
                /// <param name="capacity"></param>
                public {{{bulkTypeName}}}(int capacity = 0) : base(capacity) { }
            
                protected override async ValueTask WriteItemsToServerAsync(SqlBulkCopy bulk, CancellationToken ct)
                {
                    using var reader = new __BulkReader(this);
                    await bulk.WriteToServerAsync(reader, ct).ConfigureAwait(false);
                }
                
                protected override void ApplyColumnMappings(SqlBulkCopy bulk)
                {
            {{{BulkCopyMappings()}}}
                }

                private sealed class __BulkReader : BulkDataReaderBase
                {
                    private readonly BulkBatch<{{{dtoTypeName}}}> _batch;
                    private int _index = -1;
                    private {{{dtoTypeName}}} _item = null!;
                    private char _op;

                    public __BulkReader(BulkBatch<{{{dtoTypeName}}}> batch) => _batch = batch;

                    public override bool Read() 
                    {
                        ++_index;
                        if (_index >= _batch.Items.Count) return false;
                        
                        _item = _batch.Items[_index];
                        _op = _batch.Operations[_index].Value;
                        return true;
                    }
                     
                    public override int FieldCount => {{{dtoProps.Length + 1}}};

                    public override object GetValue(int i) => i switch
                    {
            {{{GetValueSwitch()}}}
                        {{{dtoProps.Length}}} => _op,
                        _ => throw new IndexOutOfRangeException()
                    };

                    public override string GetName(int i) => i switch
                    {
            {{{GetNameSwitch()}}}
                        {{{dtoProps.Length}}} => "Operation",
                        _ => throw new IndexOutOfRangeException()
                    };

                    public override Type GetFieldType(int i) => i switch
                    {
            {{{GetTypeSwitch()}}}
                        {{{dtoProps.Length}}} => typeof(char),
                        _ => throw new IndexOutOfRangeException()
                    };

                    public override int GetOrdinal(string name) => name switch
                    {
            {{{GetOrdinalSwitch()}}}
                        _ => -1
                    };
                }
            }
            """";

        spc.AddSource($"{dto.Name}Bulk.g.cs", src);
        return;

        string BuildApplySql(bool withIndex)
        {
            var sb = new StringBuilder();
            
            sb.AppendLine("BEGIN TRY");
            sb.AppendLine("        DECLARE @inserted INT = 0, @updated INT = 0, @deleted INT = 0;");

            if (withIndex)
            {
                sb.AppendLine(idxClause);
            }
            
            sb.AppendLine();
            
            if (nonKeyNonIdentity.Length > 0)
            {
                sb.AppendLine("        UPDATE T");
                sb.AppendLine("        SET");
                sb.AppendLine("        " + updateSet);
                sb.AppendLine($"        FROM {schemaTable} AS T");
                sb.AppendLine($"            JOIN {tempTableName} AS S ON {joinOn}");
                sb.AppendLine("        WHERE S.[Operation] = 'U';");
                sb.AppendLine("        SET @updated = @@ROWCOUNT;");
                sb.AppendLine();
            }

            if (insertCols.Length > 0)
            {
                sb.AppendLine($"        INSERT INTO {schemaTable} ({string.Join(", ", insertCols)})");
                sb.AppendLine($"        SELECT {string.Join(", ", insertSelect)}");
                sb.AppendLine($"        FROM {tempTableName} AS S");
                sb.AppendLine("        WHERE S.[Operation] = 'I';");
                sb.AppendLine("        SET @inserted = @@ROWCOUNT;");
                sb.AppendLine();
            }

            sb.AppendLine("        DELETE T");
            sb.AppendLine($"        FROM {schemaTable} AS T");
            sb.AppendLine($"            JOIN {tempTableName} AS S ON {joinOn}");
            sb.AppendLine("        WHERE S.[Operation] = 'D';");
            sb.AppendLine("        SET @deleted = @@ROWCOUNT;");
            sb.AppendLine();

            sb.AppendLine("        SELECT @inserted AS Inserted, @updated AS Updated, @deleted AS Deleted;");
            sb.AppendLine();
            
            sb.AppendLine("        END TRY");
            sb.AppendLine("        BEGIN CATCH");
            sb.AppendLine($"    {DropGuard(tempTableName)}");
            sb.AppendLine("            THROW;");
            sb.AppendLine("        END CATCH;");
            
            sb.AppendLine(DropGuard(tempTableName));

            return sb.ToString().TrimEnd();
        }

        string BulkCopyMappings()
        {
            var sb = new StringBuilder();
            foreach (var p in dtoProps)
                sb.AppendLine($"        bulk.ColumnMappings.Add(\"{p.Name}\", \"{info.ParamsByProperty[p.Name].ParameterName}\");");
            return sb.ToString().TrimEnd();
        }

        string GetNameSwitch()
        {
            var sb = new StringBuilder();
            for (var i = 0; i < dtoProps.Length; i++)
                sb.AppendLine($"            {i} => \"{info.ParamsByProperty[dtoProps[i].Name].ParameterName}\",");
            return sb.ToString().TrimEnd();
        }

        string GetTypeSwitch()
        {
            var sb = new StringBuilder();
            for (var i = 0; i < dtoProps.Length; i++)
            {
                var p = dtoProps[i];
                var t = GetUnderlyingTypeSymbol(p.Type);
                var typeName = t.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat).TrimEnd('?');
                sb.AppendLine($"            {i} => typeof({typeName}),");
            }
            return sb.ToString().TrimEnd();
        }

        string GetValueSwitch()
        {
            var sb = new StringBuilder();
            for (var i = 0; i < dtoProps.Length; i++)
            {
                var p = dtoProps[i];
                var cfg = info.ParamsByProperty[p.Name];
                var isNullable = p.IsNullableProperty(cfg);

                var expr = GetValueExpression(p, isNullable);
                sb.AppendLine($"            {i} => {expr},");
            }
            return sb.ToString().TrimEnd();
        }

        static ITypeSymbol GetUnderlyingTypeSymbol(ITypeSymbol type)
        {
            if (type is INamedTypeSymbol nts &&
                nts.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T &&
                nts.TypeArguments.Length == 1)
            {
                return nts.TypeArguments[0];
            }
            return type;
        }

        string GetValueExpression(IPropertySymbol p, bool isNullable)
        {
            // Reference nullable: item.Prop ?? (object)DBNull.Value
            if (isNullable && p.Type.IsReferenceType)
                return $"_item.{p.Name} ?? (object)DBNull.Value";

            // Nullable value type: item.Prop.HasValue ? item.Prop.Value : DBNull.Value
            if (isNullable && p.Type is INamedTypeSymbol nts &&
                nts.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T)
            {
                return $"_item.{p.Name}.HasValue ? _item.{p.Name}.Value : DBNull.Value";
            }

            // Non-nullable
            return $"_item.{p.Name}";
        }
        
        string GetOrdinalSwitch()
        {
            var sb = new StringBuilder();
            for (var i = 0; i < dtoProps.Length; i++)
                sb.AppendLine($"            \"{info.ParamsByProperty[dtoProps[i].Name].ParameterName}\" => {i},");
            sb.AppendLine($"            \"Operation\" => {dtoProps.Length},");
            return sb.ToString().TrimEnd();
        }
        
        static string DropGuard(string tempTableName)
            => $"        IF OBJECT_ID('tempdb..{tempTableName}') IS NOT NULL DROP TABLE {tempTableName};";
    }
}