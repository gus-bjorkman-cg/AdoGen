[
  {
    HintName: UserBulk.g.cs,
    Source:
// <auto-generated />
#nullable enable
using System;
using System.Data;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Data.SqlClient;
using AdoGen.Abstractions;

namespace AdoGen.Generator.Tests;

public sealed partial record User : ISqlBulkModel<global::AdoGen.Generator.Tests.User>;

public sealed class UserBulk : BulkBatch<global::AdoGen.Generator.Tests.User>
{
    private const string _tempTableName = "#AdoGen_User";

    private const string _sqlCreateTempTable =
        """
        CREATE TABLE #AdoGen_User(
            [Id] UNIQUEIDENTIFIER NOT NULL,
            [Name] VARCHAR(20) NOT NULL,
            [Email] VARCHAR(50) NOT NULL,
            [Operation] CHAR(1) NOT NULL);
        """;

    private const string _sqlApply_NoIndex =
        """
        BEGIN TRY
        DECLARE @inserted INT = 0, @updated INT = 0, @deleted INT = 0;

        UPDATE T
        SET
            T.[Name] = S.[Name],
            T.[Email] = S.[Email]
        FROM [dbo].[Users] AS T
            JOIN #AdoGen_User AS S ON S.[Id] = T.[Id]
        WHERE S.[Operation] = 'U';
        SET @updated = @@ROWCOUNT;

        INSERT INTO [dbo].[Users] ([Id], [Name], [Email])
        SELECT S.[Id], S.[Name], S.[Email]
        FROM #AdoGen_User AS S
        WHERE S.[Operation] = 'I';
        SET @inserted = @@ROWCOUNT;

        DELETE T
        FROM [dbo].[Users] AS T
            JOIN #AdoGen_User AS S ON S.[Id] = T.[Id]
        WHERE S.[Operation] = 'D';
        SET @deleted = @@ROWCOUNT;

        SELECT @inserted AS Inserted, @updated AS Updated, @deleted AS Deleted;

        END TRY
        BEGIN CATCH
            IF OBJECT_ID('tempdb..#AdoGen_User') IS NOT NULL DROP TABLE #AdoGen_User;
            THROW;
        END CATCH;
        IF OBJECT_ID('tempdb..#AdoGen_User') IS NOT NULL DROP TABLE #AdoGen_User;
        """;

    private const string _sqlApply_WithIndex =
        """
        BEGIN TRY
        DECLARE @inserted INT = 0, @updated INT = 0, @deleted INT = 0;
        CREATE INDEX [IX_AdoGen_Users_Op_Key] ON #AdoGen_User ([Operation], [Id]);

        UPDATE T
        SET
            T.[Name] = S.[Name],
            T.[Email] = S.[Email]
        FROM [dbo].[Users] AS T
            JOIN #AdoGen_User AS S ON S.[Id] = T.[Id]
        WHERE S.[Operation] = 'U';
        SET @updated = @@ROWCOUNT;

        INSERT INTO [dbo].[Users] ([Id], [Name], [Email])
        SELECT S.[Id], S.[Name], S.[Email]
        FROM #AdoGen_User AS S
        WHERE S.[Operation] = 'I';
        SET @inserted = @@ROWCOUNT;

        DELETE T
        FROM [dbo].[Users] AS T
            JOIN #AdoGen_User AS S ON S.[Id] = T.[Id]
        WHERE S.[Operation] = 'D';
        SET @deleted = @@ROWCOUNT;

        SELECT @inserted AS Inserted, @updated AS Updated, @deleted AS Deleted;

        END TRY
        BEGIN CATCH
            IF OBJECT_ID('tempdb..#AdoGen_User') IS NOT NULL DROP TABLE #AdoGen_User;
            THROW;
        END CATCH;
        IF OBJECT_ID('tempdb..#AdoGen_User') IS NOT NULL DROP TABLE #AdoGen_User;
        """;

    protected override string SqlCreateTempTable => _sqlCreateTempTable;
    protected override string TempTableName => _tempTableName;
    protected override string SqlApplyWithIndex => _sqlApply_WithIndex;
    protected override string SqlApplyNoIndex => _sqlApply_NoIndex;
    protected override int FieldCount => 4;

    /// <summary>
    /// Initializes a new instance of the BulkBatch class with an optional initial capacity for
    /// the items and operations lists.
    /// </summary>
    /// <param name="capacity"></param>
    public UserBulk(int capacity = 0) : base(capacity) { }

    protected override async ValueTask WriteItemsToServerAsync(SqlBulkCopy bulk, CancellationToken ct)
    {
        using var reader = new __BulkReader(this);
        await bulk.WriteToServerAsync(reader, ct).ConfigureAwait(false);
    }
    
    protected override void ApplyColumnMappings(SqlBulkCopy bulk)
    {
        bulk.ColumnMappings.Add("Id", "Id");
        bulk.ColumnMappings.Add("Name", "Name");
        bulk.ColumnMappings.Add("Email", "Email");
    }

    private sealed class __BulkReader : BulkDataReaderBase
    {
        private readonly BulkBatch<global::AdoGen.Generator.Tests.User> _batch;
        private int _index = -1;
        private global::AdoGen.Generator.Tests.User _item = null!;
        private char _op;

        public __BulkReader(BulkBatch<global::AdoGen.Generator.Tests.User> batch) => _batch = batch;

        public override bool Read() 
        {
            ++_index;
            if (_index >= _batch.Items.Count) return false;
            
            _item = _batch.Items[_index];
            _op = _batch.Operations[_index].Value;
            return true;
        }
         
        public override int FieldCount => 4;

        public override object GetValue(int i) => i switch
        {
            0 => _item.Id,
            1 => _item.Name,
            2 => _item.Email,
            3 => _op,
            _ => throw new IndexOutOfRangeException()
        };

        public override string GetName(int i) => i switch
        {
            0 => "Id",
            1 => "Name",
            2 => "Email",
            3 => "Operation",
            _ => throw new IndexOutOfRangeException()
        };

        public override Type GetFieldType(int i) => i switch
        {
            0 => typeof(Guid),
            1 => typeof(string),
            2 => typeof(string),
            3 => typeof(char),
            _ => throw new IndexOutOfRangeException()
        };

        public override int GetOrdinal(string name) => name switch
        {
            "Id" => 0,
            "Name" => 1,
            "Email" => 2,
            "Operation" => 3,
            _ => -1
        };
    }
}
  },
  {
    HintName: UserDomainOps.g.cs,
    Source:
// <auto-generated />
#nullable enable
using System;
using System.Data;
using System.Text;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Data.SqlClient;
using AdoGen.Abstractions;

namespace AdoGen.Generator.Tests;

public sealed partial record User : ISingleIdModel<global::AdoGen.Generator.Tests.User, global::System.Guid>
{
    private const string SqlDeleteBatchTemplate = "DELETE FROM [dbo].[Users] WHERE [Id] IN (";

    public static async ValueTask<int> DeleteAsync(SqlConnection connection, List<global::System.Guid> ids, CancellationToken ct, SqlTransaction? transaction = null, int? commandTimeout = null)
    {
        if (ids is null || ids.Count == 0) return 0;
        if (connection.State != ConnectionState.Open) await connection.OpenAsync(ct).ConfigureAwait(false);
        
        var sb = new StringBuilder(SqlDeleteBatchTemplate);
        for (var i = 0; i < ids.Count; i++)
        {
            if (i > 0) sb.Append(',');
            sb.Append($"@p{i}");
        }
        sb.Append(')');
        
        await using var cmd = connection.CreateCommand(sb.ToString(), CommandType.Text, transaction, commandTimeout);
        
        for (var i = 0; i < ids.Count; i++)
        {
            cmd.Parameters.Add(UserSql.CreateParameterId(ids[i], $"@p{i}"));
        }
        
        return await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }
}

public sealed partial record User : ISqlDomainModel<global::AdoGen.Generator.Tests.User>
{
    private const string SqlCreateTable = 
        """
        CREATE TABLE [dbo].[Users](
            [Id] UNIQUEIDENTIFIER DEFAULT NEWID() NOT NULL,
            [Name] VARCHAR(20) NOT NULL,
            [Email] VARCHAR(50) NOT NULL
        ,CONSTRAINT [PK_Users] PRIMARY KEY ([Id]));
        """;
    private const string SqlInsert = "INSERT INTO [dbo].[Users] ([Id], [Name], [Email]) VALUES (@Id, @Name, @Email);";
    private const string SqlInsertBatchTemplate = "INSERT INTO [dbo].[Users] ([Id], [Name], [Email]) VALUES";
    private const string SqlUpdate = "UPDATE [dbo].[Users] SET [Name] = @Name, [Email] = @Email WHERE [Id] = @Id;";
    private const string SqlDelete = "DELETE FROM [dbo].[Users] WHERE [Id] = @Id;";
    private const string SqlTruncate = "TRUNCATE TABLE [dbo].[Users];";
    private const string SqlUpsert = 
        """
        MERGE [dbo].[Users] AS T
           USING (VALUES(@Id, @Name, @Email)) AS S([Id], [Name], [Email])
           ON (T.[Id] = S.[Id])
           WHEN MATCHED THEN UPDATE SET T.[Name] = S.[Name], T.[Email] = S.[Email]
           WHEN NOT MATCHED THEN INSERT ([Id], [Name], [Email]) VALUES (S.[Id], S.[Name], S.[Email]);
        """;

    private const int NonIdentityPropertyCount = 3;

    public static async ValueTask CreateTableAsync(SqlConnection connection, CancellationToken ct, SqlTransaction? transaction = null, int? commandTimeout = null)
    {
        if (connection.State != ConnectionState.Open) await connection.OpenAsync(ct).ConfigureAwait(false);
        await using var cmd = connection.CreateCommand(SqlCreateTable, CommandType.Text, transaction, commandTimeout);
        await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }

    public static async ValueTask<int> InsertAsync(global::AdoGen.Generator.Tests.User model, SqlConnection connection, CancellationToken ct, SqlTransaction? transaction = null, int? commandTimeout = null)
    {
        if (connection.State != ConnectionState.Open) await connection.OpenAsync(ct).ConfigureAwait(false);
        await using var cmd = connection.CreateCommand(SqlInsert, CommandType.Text, transaction, commandTimeout);
        cmd.Parameters.Add(UserSql.CreateParameterId(model.Id));
        cmd.Parameters.Add(UserSql.CreateParameterName(model.Name));
        cmd.Parameters.Add(UserSql.CreateParameterEmail(model.Email));

        return await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }

    /// <summary>
    /// Inserts multiple database records in one roundtrip. 
    /// Will throw if parameter count exceeds SQL Server limit (2100).
    /// For type global::AdoGen.Generator.Tests.User, each record will use 3 parameters.
    /// Resulting in a max insert count of 700 per batch.
    /// For larger inserts, consider using SqlBulkCopy or multiple batches.
    /// </summary>
    /// <param name="models"></param>
    /// <param name="connection"></param>
    /// <param name="ct"></param>
    /// <param name="transaction"></param>
    /// <param name="commandTimeout"></param>
    /// <returns>Number of affected rows</returns>
    public static async ValueTask<int> InsertAsync(List<global::AdoGen.Generator.Tests.User> models, SqlConnection connection, CancellationToken ct, SqlTransaction? transaction = null, int? commandTimeout = null)
    {
        if (models is null || models.Count == 0) return 0;
        if (connection.State != ConnectionState.Open) await connection.OpenAsync(ct).ConfigureAwait(false);
        
        var sb = new StringBuilder(SqlInsertBatchTemplate);
        var paramIndex = 0;
    
        for (var modelIndex = 0; modelIndex < models.Count; modelIndex++)
        {
            if (modelIndex > 0) sb.Append(',');
    
            sb.Append('(');
    
            for (var columnIndex = 0; columnIndex < NonIdentityPropertyCount; columnIndex++)
            {
                if (columnIndex > 0) sb.Append(',');
                sb.Append($"@p{paramIndex + columnIndex}");
            }
    
            sb.Append(')');
            paramIndex += NonIdentityPropertyCount;
        }
    
        await using var cmd = connection.CreateCommand(sb.ToString(), CommandType.Text, transaction, commandTimeout);
        cmd.EnableOptimizedParameterBinding = (models.Count * NonIdentityPropertyCount) > 24;
        paramIndex = 0;
    
        foreach (var model in models)
        {
            cmd.Parameters.Add(UserSql.CreateParameterId(model.Id, $"@p{paramIndex}"));
            paramIndex++;
            cmd.Parameters.Add(UserSql.CreateParameterName(model.Name, $"@p{paramIndex}"));
            paramIndex++;
            cmd.Parameters.Add(UserSql.CreateParameterEmail(model.Email, $"@p{paramIndex}"));
            paramIndex++;
        }

        return await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }

    public static async ValueTask<int> UpdateAsync(global::AdoGen.Generator.Tests.User model, SqlConnection connection, CancellationToken ct, SqlTransaction? transaction = null, int? commandTimeout = null)
    {
        if (connection.State != ConnectionState.Open) await connection.OpenAsync(ct).ConfigureAwait(false);
        await using var cmd = connection.CreateCommand(SqlUpdate, CommandType.Text, transaction, commandTimeout);
        cmd.Parameters.Add(UserSql.CreateParameterName(model.Name));
        cmd.Parameters.Add(UserSql.CreateParameterEmail(model.Email));
        cmd.Parameters.Add(UserSql.CreateParameterId(model.Id));

        return await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }

    public static async ValueTask<int> DeleteAsync(global::AdoGen.Generator.Tests.User model, SqlConnection connection, CancellationToken ct, SqlTransaction? transaction = null, int? commandTimeout = null)
    {
        if (connection.State != ConnectionState.Open) await connection.OpenAsync(ct).ConfigureAwait(false);
        await using var cmd = connection.CreateCommand(SqlDelete, CommandType.Text, transaction, commandTimeout);
        cmd.Parameters.Add(UserSql.CreateParameterId(model.Id));

        return await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }

    public static async ValueTask<int> UpsertAsync(global::AdoGen.Generator.Tests.User model, SqlConnection connection, CancellationToken ct, SqlTransaction? transaction = null, int? commandTimeout = null)
    {
        if (connection.State != ConnectionState.Open) await connection.OpenAsync(ct).ConfigureAwait(false);
        await using var cmd = connection.CreateCommand(SqlUpsert, CommandType.Text, transaction, commandTimeout);
        cmd.Parameters.Add(UserSql.CreateParameterId(model.Id));
        cmd.Parameters.Add(UserSql.CreateParameterName(model.Name));
        cmd.Parameters.Add(UserSql.CreateParameterEmail(model.Email));

        return await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }

    public static async ValueTask<int> TruncateAsync(SqlConnection connection, CancellationToken ct, SqlTransaction? transaction = null, int? commandTimeout = null)
    {
        if (connection.State != ConnectionState.Open) await connection.OpenAsync(ct).ConfigureAwait(false);
        await using var cmd = connection.CreateCommand(SqlTruncate, CommandType.Text, transaction, commandTimeout);
        return await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }
}
  },
  {
    HintName: UserMapper.g.cs,
    Source:
// <auto-generated />
using System.Runtime.CompilerServices;
using Microsoft.Data.SqlClient;
using AdoGen.Abstractions;

namespace AdoGen.Generator.Tests;

public sealed partial record User : ISqlResult<global::AdoGen.Generator.Tests.User>
{
    private static bool IsInitialized;
    private static int IdOrdinal;
    private static int NameOrdinal;
    private static int EmailOrdinal;

    public static global::AdoGen.Generator.Tests.User Map(SqlDataReader reader)
    {
        if (!IsInitialized)
        {
            IdOrdinal = reader.GetOrdinal("Id");
            NameOrdinal = reader.GetOrdinal("Name");
            EmailOrdinal = reader.GetOrdinal("Email");

            IsInitialized = true;
        }

        return new global::AdoGen.Generator.Tests.User(
            Id : reader.GetGuid(IdOrdinal),
            Name : reader.GetString(NameOrdinal),
            Email : reader.GetString(EmailOrdinal)
        );
    }
}
  },
  {
    HintName: UserSql.g.cs,
    Source:
// <auto-generated />
#nullable enable
using System;
using System.Data;
using System.Runtime.CompilerServices;
using Microsoft.Data.SqlClient;

namespace AdoGen.Abstractions;

/// <summary>
/// Helper methods for creating typed SQL parameters for User.
/// </summary>
public static class UserSql
{
    public const string ParameterEmail = "Email";
    public const string ParameterId = "Id";
    public const string ParameterName = "Name";

    /// <summary>
    /// Creates a SqlParameter with the configured db type and size/precision/scale.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static SqlParameter CreateParameterEmail(string value, string? propertyName = null) => new()
    {
        ParameterName = propertyName ?? ParameterEmail,
        SqlDbType = SqlDbType.VarChar,
        Value = value is null ? DBNull.Value : value,
        Size = 50,
    };

    /// <summary>
    /// Creates a SqlParameter with the configured db type and size/precision/scale.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static SqlParameter CreateParameterId(global::System.Guid value, string? propertyName = null) => new()
    {
        ParameterName = propertyName ?? ParameterId,
        SqlDbType = SqlDbType.UniqueIdentifier,
        Value = value,
    };

    /// <summary>
    /// Creates a SqlParameter with the configured db type and size/precision/scale.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static SqlParameter CreateParameterName(string value, string? propertyName = null) => new()
    {
        ParameterName = propertyName ?? ParameterName,
        SqlDbType = SqlDbType.VarChar,
        Value = value is null ? DBNull.Value : value,
        Size = 20,
    };
}
  }
]