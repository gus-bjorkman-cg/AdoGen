[
  {
    HintName: UserPg.Npgsql.g.cs,
    Source:
// <auto-generated />
#nullable enable
using System;
using System.Runtime.CompilerServices;
using Npgsql;
using NpgsqlTypes;

namespace AdoGen.PostgreSql;

/// <summary>
/// Helper methods for creating typed PostgreSQL parameters for UserPg.
/// </summary>
public static class UserPgNpgsql
{
    public const string ParameterEmail = "Email";
    public const string ParameterId = "Id";
    public const string ParameterName = "Name";

    /// <summary>
    /// Creates an NpgsqlParameter with the configured db type and size/precision/scale.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static NpgsqlParameter CreateParameterEmail(string value, string? propertyName = null) => new()
    {
        ParameterName = propertyName ?? ParameterEmail,
        NpgsqlDbType = NpgsqlDbType.Varchar,
        Value = value is null ? DBNull.Value : value,
        Size = 50,
    };

    /// <summary>
    /// Creates an NpgsqlParameter with the configured db type and size/precision/scale.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static NpgsqlParameter CreateParameterId(global::System.Guid value, string? propertyName = null) => new()
    {
        ParameterName = propertyName ?? ParameterId,
        NpgsqlDbType = NpgsqlDbType.Uuid,
        Value = value,
    };

    /// <summary>
    /// Creates an NpgsqlParameter with the configured db type and size/precision/scale.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static NpgsqlParameter CreateParameterName(string value, string? propertyName = null) => new()
    {
        ParameterName = propertyName ?? ParameterName,
        NpgsqlDbType = NpgsqlDbType.Varchar,
        Value = value is null ? DBNull.Value : value,
        Size = 20,
    };
}
  },
  {
    HintName: UserPgBulk.Npgsql.g.cs,
    Source:
// <auto-generated />
#nullable enable
using System;
using System.Data;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Npgsql;
using AdoGen.PostgreSql;

namespace AdoGen.Generator.Tests;

public sealed partial record UserPg : INpgsqlBulkModel<global::AdoGen.Generator.Tests.UserPg>;

public sealed class UserPgNpgsqlBulk : BulkBatchNpg<global::AdoGen.Generator.Tests.UserPg>
{
    private const string _tempTableName = "adoGen_userpg_tmp";

    private const string _sqlCreateTempTable = @"CREATE TEMP TABLE IF NOT EXISTS ""adoGen_userpg_tmp""(
    ""Id"" UUID NOT NULL,
    ""Name"" VARCHAR(20) NOT NULL,
    ""Email"" VARCHAR(50) NOT NULL,
    ""operation"" CHAR(1) NOT NULL);";

    private const string _sqlApply = @"WITH updated AS (
    UPDATE ""public"".""UserPgs"" AS T
    SET
            ""Name"" = S.""Name"",
            ""Email"" = S.""Email""
    FROM ""adoGen_userpg_tmp"" AS S
    WHERE S.""operation"" = 'U' AND S.""Id"" = T.""Id""
    RETURNING 1
)
, inserted AS (
    INSERT INTO ""public"".""UserPgs"" (""Id"", ""Name"", ""Email"")
    SELECT S.""Id"", S.""Name"", S.""Email""
    FROM ""adoGen_userpg_tmp"" AS S
    WHERE S.""operation"" = 'I'
    RETURNING 1
)
, deleted AS (
    DELETE FROM ""public"".""UserPgs"" AS T
    USING ""adoGen_userpg_tmp"" AS S
    WHERE S.""operation"" = 'D' AND S.""Id"" = T.""Id""
    RETURNING 1
)
SELECT
    (SELECT COUNT(*) FROM inserted) AS Inserted,
    (SELECT COUNT(*) FROM updated) AS Updated,
    (SELECT COUNT(*) FROM deleted) AS Deleted;";

    private const string _copyCommand = "COPY \"adoGen_userpg_tmp\" (\"Id\", \"Name\", \"Email\", \"operation\") FROM STDIN (FORMAT BINARY)";

    protected override string SqlCreateTempTable => _sqlCreateTempTable;
    protected override string TempTableName => _tempTableName;
    protected override string SqlApplyWithIndex => _sqlApply;
    protected override string SqlApplyNoIndex => _sqlApply;
    protected override int FieldCount => 4;

    public UserPgNpgsqlBulk(int capacity = 0) : base(capacity) { }

    protected override async ValueTask WriteItemsToServerAsync(NpgsqlConnection connection, NpgsqlTransaction transaction, CancellationToken ct)
    {
        // COPY BINARY is the fast path in PostgreSQL.
        // Note: BeginBinaryImport is sync in Npgsql; we still honor CancellationToken during row loop via Write...Async.
        await using var importer = connection.BeginBinaryImport(_copyCommand);

        for (var i = 0; i < Items.Count; i++)
        {
            ct.ThrowIfCancellationRequested();

            var item = Items[i];
            var op = Operations[i].Value;

            await importer.StartRowAsync(ct).ConfigureAwait(false);
            importer.Write(item.Id);
            importer.Write(item.Name);
            importer.Write(item.Email);
            importer.Write(op);
        }

        await importer.CompleteAsync(ct).ConfigureAwait(false);
    }
}
  },
  {
    HintName: UserPgDomainOps.Npgsql.g.cs,
    Source:
// <auto-generated />
#nullable enable
using System;
using System.Data;
using System.Text;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Npgsql;
using AdoGen.PostgreSql;

namespace AdoGen.Generator.Tests;

public sealed partial record UserPg : INpgsqlSingleIdModel<global::AdoGen.Generator.Tests.UserPg, global::System.Guid>
{
    private const string Pg_SqlDeleteBatchTemplate = "DELETE FROM \"public\".\"UserPgs\" WHERE \"Id\" IN (";

    public static async ValueTask<int> DeleteAsync(NpgsqlConnection connection, List<global::System.Guid> ids, CancellationToken ct, NpgsqlTransaction? transaction = null, int? commandTimeout = null)
    {
        if (ids is null || ids.Count == 0) return 0;
        if (connection.State != ConnectionState.Open) await connection.OpenAsync(ct).ConfigureAwait(false);

        var sb = new StringBuilder(Pg_SqlDeleteBatchTemplate);
        for (var i = 0; i < ids.Count; i++)
        {
            if (i > 0) sb.Append(',');
            sb.Append($"@p{i}");
        }
        sb.Append(')');

        await using var cmd = connection.CreateCommand(sb.ToString(), CommandType.Text, transaction, commandTimeout);

        for (var i = 0; i < ids.Count; i++)
        {
            cmd.Parameters.Add(UserPgNpgsql.CreateParameterId(ids[i], $"@p{i}"));
        }

        return await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }
}

public sealed partial record UserPg : INpgsqlDomainModel<global::AdoGen.Generator.Tests.UserPg>
{
    private const string Pg_SqlCreateTable = @"CREATE TABLE IF NOT EXISTS ""public"".""UserPgs""(
            ""Id"" UUID DEFAULT gen_random_uuid() NOT NULL,
            ""Name"" VARCHAR(20) NOT NULL,
            ""Email"" VARCHAR(50) NOT NULL
        ,CONSTRAINT ""PK_UserPgs"" PRIMARY KEY (""Id""));
";
    private const string Pg_SqlInsert = "INSERT INTO \"public\".\"UserPgs\" (\"Id\", \"Name\", \"Email\") VALUES (@Id, @Name, @Email);";
    private const string Pg_SqlInsertBatchTemplate = "INSERT INTO \"public\".\"UserPgs\" (\"Id\", \"Name\", \"Email\") VALUES";
    private const string Pg_SqlUpdate = "UPDATE \"public\".\"UserPgs\" SET \"Name\" = @Name, \"Email\" = @Email WHERE \"Id\" = @Id;";
    private const string Pg_SqlDelete = "DELETE FROM \"public\".\"UserPgs\" WHERE \"Id\" = @Id;";
    private const string Pg_SqlTruncate = "TRUNCATE TABLE \"public\".\"UserPgs\";";
    private const string Pg_SqlUpsert = "INSERT INTO \"public\".\"UserPgs\" (\"Id\", \"Name\", \"Email\") VALUES (@Id, @Name, @Email) ON CONFLICT (\"Id\") DO UPDATE SET \"Name\" = EXCLUDED.\"Name\", \"Email\" = EXCLUDED.\"Email\";";

    private const int Pg_NonIdentityPropertyCount = 3;

    public static async ValueTask CreateTableAsync(NpgsqlConnection connection, CancellationToken ct, NpgsqlTransaction? transaction = null, int? commandTimeout = null)
    {
        if (connection.State != ConnectionState.Open) await connection.OpenAsync(ct).ConfigureAwait(false);
        await using var cmd = connection.CreateCommand(Pg_SqlCreateTable, CommandType.Text, transaction, commandTimeout);
        await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }

    public static async ValueTask<int> InsertAsync(global::AdoGen.Generator.Tests.UserPg model, NpgsqlConnection connection, CancellationToken ct, NpgsqlTransaction? transaction = null, int? commandTimeout = null)
    {
        if (connection.State != ConnectionState.Open) await connection.OpenAsync(ct).ConfigureAwait(false);
        await using var cmd = connection.CreateCommand(Pg_SqlInsert, CommandType.Text, transaction, commandTimeout);
        cmd.Parameters.Add(UserPgNpgsql.CreateParameterId(model.Id));
        cmd.Parameters.Add(UserPgNpgsql.CreateParameterName(model.Name));
        cmd.Parameters.Add(UserPgNpgsql.CreateParameterEmail(model.Email));
        return await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }

    public static async ValueTask<int> InsertAsync(List<global::AdoGen.Generator.Tests.UserPg> models, NpgsqlConnection connection, CancellationToken ct, NpgsqlTransaction? transaction = null, int? commandTimeout = null)
    {
        if (models is null || models.Count == 0) return 0;
        if (connection.State != ConnectionState.Open) await connection.OpenAsync(ct).ConfigureAwait(false);

        var sb = new StringBuilder(Pg_SqlInsertBatchTemplate);
        var paramIndex = 0;

        for (var modelIndex = 0; modelIndex < models.Count; modelIndex++)
        {
            if (modelIndex > 0) sb.Append(',');
            sb.Append('(');
            for (var columnIndex = 0; columnIndex < Pg_NonIdentityPropertyCount; columnIndex++)
            {
                if (columnIndex > 0) sb.Append(',');
                sb.Append($"@p{paramIndex + columnIndex}");
            }
            sb.Append(')');
            paramIndex += Pg_NonIdentityPropertyCount;
        }

        await using var cmd = connection.CreateCommand(sb.ToString(), CommandType.Text, transaction, commandTimeout);
        paramIndex = 0;

        foreach (var model in models)
        {
            cmd.Parameters.Add(UserPgNpgsql.CreateParameterId(model.Id, $"@p{paramIndex}"));
            paramIndex++; 
            cmd.Parameters.Add(UserPgNpgsql.CreateParameterName(model.Name, $"@p{paramIndex}"));
            paramIndex++; 
            cmd.Parameters.Add(UserPgNpgsql.CreateParameterEmail(model.Email, $"@p{paramIndex}"));
            paramIndex++; 
        }

        return await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }

    public static async ValueTask<int> UpdateAsync(global::AdoGen.Generator.Tests.UserPg model, NpgsqlConnection connection, CancellationToken ct, NpgsqlTransaction? transaction = null, int? commandTimeout = null)
    {
        if (connection.State != ConnectionState.Open) await connection.OpenAsync(ct).ConfigureAwait(false);
        await using var cmd = connection.CreateCommand(Pg_SqlUpdate, CommandType.Text, transaction, commandTimeout);
        cmd.Parameters.Add(UserPgNpgsql.CreateParameterName(model.Name));
        cmd.Parameters.Add(UserPgNpgsql.CreateParameterEmail(model.Email));
        cmd.Parameters.Add(UserPgNpgsql.CreateParameterId(model.Id));
        return await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }

    public static async ValueTask<int> DeleteAsync(global::AdoGen.Generator.Tests.UserPg model, NpgsqlConnection connection, CancellationToken ct, NpgsqlTransaction? transaction = null, int? commandTimeout = null)
    {
        if (connection.State != ConnectionState.Open) await connection.OpenAsync(ct).ConfigureAwait(false);
        await using var cmd = connection.CreateCommand(Pg_SqlDelete, CommandType.Text, transaction, commandTimeout);
        cmd.Parameters.Add(UserPgNpgsql.CreateParameterId(model.Id));
        return await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }

    public static async ValueTask<int> UpsertAsync(global::AdoGen.Generator.Tests.UserPg model, NpgsqlConnection connection, CancellationToken ct, NpgsqlTransaction? transaction = null, int? commandTimeout = null)
    {
        if (connection.State != ConnectionState.Open) await connection.OpenAsync(ct).ConfigureAwait(false);
        await using var cmd = connection.CreateCommand(Pg_SqlUpsert, CommandType.Text, transaction, commandTimeout);
        cmd.Parameters.Add(UserPgNpgsql.CreateParameterId(model.Id));
        cmd.Parameters.Add(UserPgNpgsql.CreateParameterName(model.Name));
        cmd.Parameters.Add(UserPgNpgsql.CreateParameterEmail(model.Email));
        return await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }

    public static async ValueTask<int> TruncateAsync(NpgsqlConnection connection, CancellationToken ct, NpgsqlTransaction? transaction = null, int? commandTimeout = null)
    {
        if (connection.State != ConnectionState.Open) await connection.OpenAsync(ct).ConfigureAwait(false);
        await using var cmd = connection.CreateCommand(Pg_SqlTruncate, CommandType.Text, transaction, commandTimeout);
        return await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }
}

  },
  {
    HintName: UserPgMapper.Npgsql.g.cs,
    Source:
// <auto-generated />
using System.Runtime.CompilerServices;
using Npgsql;
using AdoGen.PostgreSql;

namespace AdoGen.Generator.Tests;

public sealed partial record UserPg : INpgsqlResult<global::AdoGen.Generator.Tests.UserPg>
{
    private static bool Pg_IsInitialized;
    private static int Pg_IdOrdinal;
    private static int Pg_NameOrdinal;
    private static int Pg_EmailOrdinal;

    public static global::AdoGen.Generator.Tests.UserPg Map(NpgsqlDataReader reader)
    {
        if (!Pg_IsInitialized)
        {
            Pg_IdOrdinal = reader.GetOrdinal("Id");
            Pg_NameOrdinal = reader.GetOrdinal("Name");
            Pg_EmailOrdinal = reader.GetOrdinal("Email");

            Pg_IsInitialized = true;
        }

        return new global::AdoGen.Generator.Tests.UserPg(
            Id : reader.GetGuid(Pg_IdOrdinal),
            Name : reader.GetString(Pg_NameOrdinal),
            Email : reader.GetString(Pg_EmailOrdinal)
        );
    }
}
  }
]